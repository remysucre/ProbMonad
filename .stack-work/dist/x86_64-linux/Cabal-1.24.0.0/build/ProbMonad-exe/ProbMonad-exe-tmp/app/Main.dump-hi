
==================== FINAL INTERFACE ====================
2016-10-02 03:32:24.502608253 UTC

interface main@main:Main [orphan module] 8001
  interface hash: 399d4dfdd65309313e44895d3c44424d
  ABI hash: 2dbd3bb821bff787cd030e222fb92ed8
  export-list hash: 74088cdbb80401fd52e9bbfec1eb9595
  orphan hash: 4a25b6b863c473a6977ff128f91398e8
  flag hash: 463ebe22efe2f878c847ee43f550adca
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.infer
  Main.inferDieNCoins
  Main.inferDummy
  Main.main
  Main.simpleDieNCoins
module dependencies:
package dependencies: ProbMonad-0.1.0.0@ProbMonad-0.1.0.0-HzyMXLsBCzOJ3IcnWfm09n
                      array-0.5.1.1@array-0.5.1.1 base-4.9.0.0
                      control-monad-omega-0.3.1@control-monad-omega-0.3.1-7sfKsMqxG77EECtPWW2L1K
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      enumerable-0.0.3@enumerable-0.0.3-3Oga6GEA2O6751ICIDFn2E
                      ghc-prim-0.5.0.0 integer-gmp-1.0.0.1
                      tagged-0.8.5@tagged-0.8.5-CtgV6EcN0do8F92i1S6iYx
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
                         tagged-0.8.5@tagged-0.8.5-CtgV6EcN0do8F92i1S6iYx:Data.Tagged
import  -/  ProbMonad-0.1.0.0@ProbMonad-0.1.0.0-HzyMXLsBCzOJ3IcnWfm09n:Gamble 75ee54c4252a96047b701a7d8f5109eb
import  -/  ProbMonad-0.1.0.0@ProbMonad-0.1.0.0-HzyMXLsBCzOJ3IcnWfm09n:Infer a28cd3c5964202940a20182802a46903
import  -/  ProbMonad-0.1.0.0@ProbMonad-0.1.0.0-HzyMXLsBCzOJ3IcnWfm09n:Simulate 5361a3c25204a2290f05dff320715842
import  -/  base-4.9.0.0:Control.Monad 7767aebfd53f0b584cef2fe66ad3986c
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:Data.List 49b86831b79b49ce5d4d9416ecba61df
import  -/  base-4.9.0.0:Data.Traversable 7ce5b7ee67475ac3d03ae825b86efd9f
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.List 13d2451194c1c6e53b4f4f07947736dd
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  base-4.9.0.0:System.IO eb1d40aa793a4047069a5023f2ebcfe3
import  -/  enumerable-0.0.3@enumerable-0.0.3-3Oga6GEA2O6751ICIDFn2E:Data.Enumerable 48862368ec7bf3c1f36a4c007196b94d
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 7378e41b7749213c8c88ceb6b0665d4c
806fbacefc485e0c696c2545e6055c3c
  $fEnumerableFlip :: Data.Enumerable.Enumerable Gamble.Flip
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Gamble.Flip
                  Main.$fEnumerableFlip3
                  Main.$fEnumerableFlip_$cenumerateTotal
                  Main.$fEnumerableFlip_$cenumeratePartial
                  Main.$fEnumerableFlip_$cisPartial -}
1a20c0c7be956b9e016acdca06e4dff5
  $fEnumerableFlip1 :: [Gamble.Flip]
  {- Unfolding: (GHC.Types.:
                   @ Gamble.Flip
                   Main.$fEnumerableFlip2
                   (GHC.Types.[] @ Gamble.Flip)) -}
b2eb514df104600b7230412a32abee09
  $fEnumerableFlip2 :: Gamble.Flip
  {- Strictness: x -}
38ba526b70f4e446b23b0ed4d7b102bd
  $fEnumerableFlip3 :: [Gamble.Flip]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ Gamble.Flip
                   Gamble.H
                   Main.$fEnumerableFlip4) -}
d344eef85b10db35917d8e27ef9a17e2
  $fEnumerableFlip4 :: [Gamble.Flip]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ Gamble.Flip
                   Gamble.T
                   (GHC.Types.[] @ Gamble.Flip)) -}
0314ddd00f1cc5aa18d02d1d61494716
  $fEnumerableFlip_$cenumeratePartial :: [Gamble.Flip]
  {- Unfolding: (GHC.Base.++
                   @ Gamble.Flip
                   Main.$fEnumerableFlip3
                   Main.$fEnumerableFlip1) -}
e76cb1bfd40f75e05facd3e33a1cf9d4
  $fEnumerableFlip_$cenumerateTotal :: [Gamble.Flip]
  {- Strictness: m2,
     Unfolding: InlineRule (0, True, True) Main.$fEnumerableFlip3 -}
f9b2fdc5751319d5c25a88278854f829
  $fEnumerableFlip_$cisPartial ::
    Data.Tagged.Tagged Gamble.Flip GHC.Types.Bool
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True)
                GHC.Types.False
                  `cast`
                (Sym (Data.Tagged.N:Tagged[0]
                          <*>_N <Gamble.Flip>_P <GHC.Types.Bool>_R)) -}
e113f09bc5a0dd760f4097dfab64c9b0
  $fEnumerableRoll :: Data.Enumerable.Enumerable Gamble.Roll
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Gamble.Roll
                  Main.$fEnumerableRoll_$cenumerate
                  Main.$fEnumerableRoll_$cenumerateTotal
                  Main.$fEnumerableRoll_$cenumeratePartial
                  Main.$fEnumerableRoll_$cisPartial -}
3974dd15f3d6ccce38bd9e1bf6269738
  $fEnumerableRoll1 :: [Gamble.Roll]
  {- Unfolding: (GHC.Types.:
                   @ Gamble.Roll
                   Main.$fEnumerableRoll2
                   (GHC.Types.[] @ Gamble.Roll)) -}
d88f3743cd548024d5e24939965a0b57
  $fEnumerableRoll2 :: Gamble.Roll
  {- Strictness: x -}
69806998334b21068e33ba8eb7384278
  $fEnumerableRoll_$cenumerate :: [Gamble.Roll]
  {- Unfolding: (case Main.$wgo 1# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ Gamble.Roll ww1 ww2 }) -}
b4e8dc31e42af0999b9611bc16e05ac2
  $fEnumerableRoll_$cenumeratePartial :: [Gamble.Roll]
  {- Unfolding: (GHC.Base.++
                   @ Gamble.Roll
                   Main.$fEnumerableRoll_$cenumerate
                   Main.$fEnumerableRoll1) -}
c9b85dabce2550b18159b6e9755c22ce
  $fEnumerableRoll_$cenumerateTotal :: [Gamble.Roll]
  {- Unfolding: InlineRule (0, True, True)
                Main.$fEnumerableRoll_$cenumerate -}
c7b357998a8e96123b7eff0724ac024d
  $fEnumerableRoll_$cisPartial ::
    Data.Tagged.Tagged Gamble.Roll GHC.Types.Bool
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True)
                GHC.Types.False
                  `cast`
                (Sym (Data.Tagged.N:Tagged[0]
                          <*>_N <Gamble.Roll>_P <GHC.Types.Bool>_R)) -}
d6831ef04cb9301b090dfae6f7bb7ec7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule2 Main.$trModule1) -}
847d9fc3b8e6f0b424199f36b4999bb2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Main"#) -}
24ef6042833e75ffd7aa98b83ecca98d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
4fe79984f7373278cc1bdaa85e83639c
  $w$sinfer ::
    (Gamble.Flip -> Simulate.P GHC.Integer.Type.Integer)
    -> Simulate.P GHC.Integer.Type.Integer
    -> (# [(Gamble.Flip, GHC.Real.Rational)] #)
  {- Arity: 2, Strictness: <L,C(U(1*U))><L,U(U)>, Inline: [0],
     Unfolding: (\ (w :: Gamble.Flip
                         -> Simulate.P GHC.Integer.Type.Integer)
                   (w1 :: Simulate.P GHC.Integer.Type.Integer) ->
                 (# GHC.Base.map
                      @ Gamble.Flip
                      @ (Gamble.Flip, GHC.Real.Rational)
                      (\ (x :: Gamble.Flip) ->
                       (x,
                        case w x of wild { Simulate.P xps ->
                        letrec {
                          $wgo6 :: [(GHC.Integer.Type.Integer, GHC.Real.Rational)]
                                   -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
                            {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                          = \ (w2 :: [(GHC.Integer.Type.Integer, GHC.Real.Rational)]) ->
                            case w2 of wild1 {
                              [] -> (# Main.infer_dt, GHC.Real.$fEnumRatio1 #)
                              : y ys
                              -> case y of wild2 { (,) x1 px ->
                                 case w1 of wild3 { Simulate.P yps ->
                                 letrec {
                                   $wgo7 :: [(GHC.Integer.Type.Integer, GHC.Real.Rational)]
                                            -> (# GHC.Integer.Type.Integer,
                                                  GHC.Integer.Type.Integer #)
                                     {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                                   = \ (w3 :: [(GHC.Integer.Type.Integer, GHC.Real.Rational)]) ->
                                     case w3 of wild4 {
                                       [] -> (# Main.infer_dt, GHC.Real.$fEnumRatio1 #)
                                       : y1 ys1
                                       -> case y1 of wild5 { (,) y2 py ->
                                          case GHC.Integer.Type.eqInteger#
                                                 x1
                                                 y2 of wild6 { DEFAULT ->
                                          case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild6 of wild7 {
                                            GHC.Types.False -> $wgo7 ys1
                                            GHC.Types.True
                                            -> case py of ww { GHC.Real.:% ww1 ww2 ->
                                               case $wgo7 ys1 of ww4 { (#,#) ww5 ww6 ->
                                               GHC.Real.$w$s$c+ ww1 ww2 ww5 ww6 } } } } } }
                                 } in
                                 case $wgo7 yps of ww { (#,#) ww1 ww2 ->
                                 case px of ww3 { GHC.Real.:% ww4 ww5 ->
                                 case GHC.Real.$w$sreduce
                                        (GHC.Integer.Type.timesInteger ww1 ww4)
                                        (GHC.Integer.Type.timesInteger
                                           ww2
                                           ww5) of ww6 { (#,#) ww7 ww8 ->
                                 case $wgo6 ys of ww9 { (#,#) ww10 ww11 ->
                                 GHC.Real.$w$s$c+ ww7 ww8 ww10 ww11 } } } } } } }
                        } in
                        case $wgo6 xps of ww { (#,#) ww1 ww2 ->
                        GHC.Real.:% @ GHC.Integer.Type.Integer ww1 ww2 } }))
                      Main.$fEnumerableFlip3 #)) -}
2bd0e84ca9ad22028ed9356091e112f8
  $w$sinfer1 ::
    (Gamble.Roll -> Simulate.P GHC.Types.Int)
    -> Simulate.P GHC.Types.Int
    -> (# [(Gamble.Roll, GHC.Real.Rational)] #)
  {- Arity: 2, Strictness: <L,C(U(1*U))><L,U(U)>, Inline: [0],
     Unfolding: (\ (w :: Gamble.Roll -> Simulate.P GHC.Types.Int)
                   (w1 :: Simulate.P GHC.Types.Int) ->
                 (# GHC.Base.map
                      @ Gamble.Roll
                      @ (Gamble.Roll, GHC.Real.Rational)
                      (\ (x :: Gamble.Roll) ->
                       (x,
                        case w x of wild { Simulate.P xps ->
                        letrec {
                          $wgo6 :: [(GHC.Types.Int, GHC.Real.Rational)]
                                   -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
                            {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                          = \ (w2 :: [(GHC.Types.Int, GHC.Real.Rational)]) ->
                            case w2 of wild1 {
                              [] -> (# Main.infer_dt, GHC.Real.$fEnumRatio1 #)
                              : y ys
                              -> case y of wild2 { (,) x1 px ->
                                 case w1 of wild3 { Simulate.P yps ->
                                 letrec {
                                   $wgo7 :: [(GHC.Types.Int, GHC.Real.Rational)]
                                            -> (# GHC.Integer.Type.Integer,
                                                  GHC.Integer.Type.Integer #)
                                     {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                                   = \ (w3 :: [(GHC.Types.Int, GHC.Real.Rational)]) ->
                                     case w3 of wild4 {
                                       [] -> (# Main.infer_dt, GHC.Real.$fEnumRatio1 #)
                                       : y1 ys1
                                       -> case y1 of wild5 { (,) y2 py ->
                                          case x1 of wild6 { GHC.Types.I# x2 ->
                                          case y2 of wild7 { GHC.Types.I# y3 ->
                                          case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.==# x2 y3) of wild8 {
                                            GHC.Types.False -> $wgo7 ys1
                                            GHC.Types.True
                                            -> case py of ww { GHC.Real.:% ww1 ww2 ->
                                               case $wgo7 ys1 of ww4 { (#,#) ww5 ww6 ->
                                               GHC.Real.$w$s$c+ ww1 ww2 ww5 ww6 } } } } } } }
                                 } in
                                 case $wgo7 yps of ww { (#,#) ww1 ww2 ->
                                 case px of ww3 { GHC.Real.:% ww4 ww5 ->
                                 case GHC.Real.$w$sreduce
                                        (GHC.Integer.Type.timesInteger ww1 ww4)
                                        (GHC.Integer.Type.timesInteger
                                           ww2
                                           ww5) of ww6 { (#,#) ww7 ww8 ->
                                 case $wgo6 ys of ww9 { (#,#) ww10 ww11 ->
                                 GHC.Real.$w$s$c+ ww7 ww8 ww10 ww11 } } } } } } }
                        } in
                        case $wgo6 xps of ww { (#,#) ww1 ww2 ->
                        GHC.Real.:% @ GHC.Integer.Type.Integer ww1 ww2 } }))
                      Main.$fEnumerableRoll_$cenumerate #)) -}
830dd11595533e522fc138fbe04445c7
  $wgo :: GHC.Prim.Int# -> (# Gamble.Roll, [Gamble.Roll] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>, Inline: [0] -}
08d27f7432ced5020b4a6ca37579f0ba
  $wgo1 :: [Gamble.Flip] -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
70bf53bdd21aba02c15415c4b1c3bbe3
  $wgo2 ::
    [Simulate.P Gamble.Flip]
    -> (# [([Gamble.Flip], GHC.Real.Rational)] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
9c84697146d4f94917d1ad521523cee7
  $wgo3 :: [Gamble.Flip] -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
fdf176c0f05f52316ef2fe908ee25f29
  $wgo4 ::
    [Simulate.P Gamble.Flip]
    -> (# [([Gamble.Flip], GHC.Real.Rational)] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
fbdd1a24fcc63263eb7a38758af78407
  $winfer ::
    (Data.Enumerable.Enumerable a, GHC.Classes.Eq b) =>
    (a -> Simulate.P b)
    -> Simulate.P b -> (# [(a, GHC.Real.Rational)] #)
  {- Arity: 4,
     Strictness: <L,1*U(1*U,A,A,A)><L,U(C(C1(U)),A)><L,C(U(1*U))><L,U(U)>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: Data.Enumerable.Enumerable a)
                   (w1 :: GHC.Classes.Eq b)
                   (w2 :: a -> Simulate.P b)
                   (w3 :: Simulate.P b) ->
                 (# GHC.Base.map
                      @ a
                      @ (a, GHC.Real.Rational)
                      (\ (x :: a) ->
                       (x,
                        case w2 x of wild { Simulate.P xps ->
                        letrec {
                          $wgo6 :: [(b, GHC.Real.Rational)]
                                   -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
                            {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                          = \ (w4 :: [(b, GHC.Real.Rational)]) ->
                            case w4 of wild1 {
                              [] -> (# Main.infer_dt, GHC.Real.$fEnumRatio1 #)
                              : y ys
                              -> case y of wild2 { (,) x1 px ->
                                 case w3 of wild3 { Simulate.P yps ->
                                 letrec {
                                   $wgo7 :: [(b, GHC.Real.Rational)]
                                            -> (# GHC.Integer.Type.Integer,
                                                  GHC.Integer.Type.Integer #)
                                     {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                                   = \ (w5 :: [(b, GHC.Real.Rational)]) ->
                                     case w5 of wild4 {
                                       [] -> (# Main.infer_dt, GHC.Real.$fEnumRatio1 #)
                                       : y1 ys1
                                       -> case y1 of wild5 { (,) y2 py ->
                                          case GHC.Classes.== @ b w1 x1 y2 of wild6 {
                                            GHC.Types.False -> $wgo7 ys1
                                            GHC.Types.True
                                            -> case py of ww { GHC.Real.:% ww1 ww2 ->
                                               case $wgo7 ys1 of ww4 { (#,#) ww5 ww6 ->
                                               GHC.Real.$w$s$c+ ww1 ww2 ww5 ww6 } } } } }
                                 } in
                                 case $wgo7 yps of ww { (#,#) ww1 ww2 ->
                                 case px of ww3 { GHC.Real.:% ww4 ww5 ->
                                 case GHC.Real.$w$sreduce
                                        (GHC.Integer.Type.timesInteger ww1 ww4)
                                        (GHC.Integer.Type.timesInteger
                                           ww2
                                           ww5) of ww6 { (#,#) ww7 ww8 ->
                                 case $wgo6 ys of ww9 { (#,#) ww10 ww11 ->
                                 GHC.Real.$w$s$c+ ww7 ww8 ww10 ww11 } } } } } } }
                        } in
                        case $wgo6 xps of ww { (#,#) ww1 ww2 ->
                        GHC.Real.:% @ GHC.Integer.Type.Integer ww1 ww2 } }))
                      (Data.Enumerable.enumerate @ a w) #)) -}
9022836de72beccae49092a3366af603
  $wxs :: GHC.Prim.Int# -> [Simulate.P Gamble.Flip]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
05c58c4c1858a1bc4d93f9a453dba48c
  infer ::
    (Data.Enumerable.Enumerable a, GHC.Classes.Eq b) =>
    (a -> Simulate.P b) -> Simulate.P b -> Simulate.P a
  {- Arity: 4,
     Strictness: <L,1*U(1*U,A,A,A)><L,U(C(C1(U)),A)><L,C(U(1*U))><L,U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: Data.Enumerable.Enumerable a)
                   (w1 :: GHC.Classes.Eq b)
                   (w2 :: a -> Simulate.P b)
                   (w3 :: Simulate.P b) ->
                 case Main.$winfer @ a @ b w w1 w2 w3 of ww { Unit# ww1 ->
                 Simulate.P @ a ww1 }) -}
2046ac9774640b5b13b7a5b2c280f111
  inferDieNCoins :: Simulate.P Gamble.Roll
  {- Unfolding: (case Main.$w$sinfer1
                        Main.inferDieNCoins7
                        Main.inferDieNCoins1 of ww { Unit# ww1 ->
                 Simulate.P @ Gamble.Roll ww1 }) -}
e00184d9291a55caaf1694b4925ee620
  inferDieNCoins1 :: Simulate.P GHC.Types.Int
  {- HasNoCafRefs,
     Unfolding: (Simulate.P @ GHC.Types.Int Main.inferDieNCoins2) -}
a25cbdc6df77ea00de13b1e3dcc457ea
  inferDieNCoins2 :: [(GHC.Types.Int, GHC.Real.Rational)]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ (GHC.Types.Int, GHC.Real.Rational)
                   Main.inferDieNCoins3
                   (GHC.Types.[] @ (GHC.Types.Int, GHC.Real.Rational))) -}
43b038b73f511d3290348ba6148d7215
  inferDieNCoins3 :: (GHC.Types.Int, GHC.Real.Rational)
  {- HasNoCafRefs,
     Unfolding: ((Main.inferDieNCoins6, Main.inferDieNCoins4)) -}
fd96531712829119f004ad1a6c84114f
  inferDieNCoins4 :: GHC.Real.Ratio GHC.Integer.Type.Integer
  {- HasNoCafRefs,
     Unfolding: (GHC.Real.:%
                   @ GHC.Integer.Type.Integer
                   Main.inferDieNCoins5
                   GHC.Real.$fEnumRatio1) -}
4bd180ea4a88341204080083086241fd
  inferDieNCoins5 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
20c29eb813d3609cfc65615930892fd4
  inferDieNCoins6 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 3#) -}
0ce6f0531b3ebf0f077e8330253c504d
  inferDieNCoins7 :: Gamble.Roll -> Simulate.P GHC.Types.Int
  {- Arity: 1,
     Unfolding: (\ (x :: Gamble.Roll) ->
                 case x of wild { Gamble.Face n ->
                 case n of wild1 { GHC.Types.I# y ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0# y) of wild2 {
                   GHC.Types.False
                   -> case Main.$wgo2
                             (GHC.Types.[] @ (Simulate.P Gamble.Flip)) of ww { Unit# ww1 ->
                      case Simulate.$w$c>>=
                             @ [Gamble.Flip]
                             @ GHC.Types.Int
                             ww1
                             Main.inferDieNCoins_g of ww2 { Unit# ww3 ->
                      Simulate.P @ GHC.Types.Int ww3 } }
                   GHC.Types.True
                   -> case Main.$wgo2 (Main.$wxs y) of ww { Unit# ww1 ->
                      case Simulate.$w$c>>=
                             @ [Gamble.Flip]
                             @ GHC.Types.Int
                             ww1
                             Main.inferDieNCoins_g of ww2 { Unit# ww3 ->
                      Simulate.P @ GHC.Types.Int ww3 } } } } }) -}
be82cddf1ebb16fa43768f61fe7a46ef
  inferDieNCoins_g :: [Gamble.Flip] -> Simulate.P GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [Gamble.Flip]) ->
                 Simulate.P
                   @ GHC.Types.Int
                   (GHC.Types.:
                      @ (GHC.Types.Int, GHC.Real.Rational)
                      (case Main.$wgo1 w 0# of ww { DEFAULT -> GHC.Types.I# ww },
                       Simulate.$fApplicativeP1)
                      (GHC.Types.[] @ (GHC.Types.Int, GHC.Real.Rational)))) -}
c9b6aa8b44f133bb374a5e7f62d3e0a8
  inferDummy :: Simulate.P Gamble.Flip
  {- Unfolding: (case Main.$w$sinfer
                        Main.inferDummy5
                        Main.inferDummy1 of ww { Unit# ww1 ->
                 Simulate.P @ Gamble.Flip ww1 }) -}
cb0a052375f3a2f86f4ba4b82f6b8243
  inferDummy1 :: Simulate.P GHC.Integer.Type.Integer
  {- HasNoCafRefs,
     Unfolding: (Simulate.P
                   @ GHC.Integer.Type.Integer
                   Main.inferDummy2) -}
8f62842e06beb659e82edf1f0d0470b6
  inferDummy10 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
10187677d9b74f1486221902d7add84f
  inferDummy2 :: [(GHC.Integer.Type.Integer, GHC.Real.Rational)]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ (GHC.Integer.Type.Integer, GHC.Real.Rational)
                   Main.inferDummy3
                   (GHC.Types.[] @ (GHC.Integer.Type.Integer, GHC.Real.Rational))) -}
24eeff8d59780f1b9847588c32ea367d
  inferDummy3 :: (GHC.Integer.Type.Integer, GHC.Real.Rational)
  {- HasNoCafRefs,
     Unfolding: ((Main.inferDummy4, Main.inferDieNCoins4)) -}
bfe3ff814cf48bdb01acdec65a915976
  inferDummy4 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (3) -}
db2b2fe5a9bb11eaa498c3783d51a74c
  inferDummy5 :: Gamble.Flip -> Simulate.P GHC.Integer.Type.Integer
  {- Arity: 1,
     Unfolding: (\ (f :: Gamble.Flip) ->
                 case f of wild {
                   Gamble.H -> Main.inferDummy8 Gamble.T -> Main.inferDummy6 }) -}
09a157555d111a9298b94df76b4a9a15
  inferDummy6 :: Simulate.P GHC.Integer.Type.Integer
  {- Unfolding: (case Simulate.$wuniform
                        @ GHC.Integer.Type.Integer
                        Main.inferDummy7 of ww { Unit# ww1 ->
                 Simulate.P @ GHC.Integer.Type.Integer ww1 }) -}
fffa225afc3ec10d62d2f1c2cfe929c6
  inferDummy7 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   Main.inferDummy4
                   (GHC.Types.[] @ GHC.Integer.Type.Integer)) -}
69cc7361600da469c84a52a5fd259a43
  inferDummy8 :: Simulate.P GHC.Integer.Type.Integer
  {- Unfolding: (case Simulate.$wuniform
                        @ GHC.Integer.Type.Integer
                        Main.inferDummy9 of ww { Unit# ww1 ->
                 Simulate.P @ GHC.Integer.Type.Integer ww1 }) -}
bb40a3aaecf2fb075a85325d438430cc
  inferDummy9 :: [GHC.Integer.Type.Integer]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   Main.inferDummy10
                   (GHC.Types.[] @ GHC.Integer.Type.Integer)) -}
7629db1c989a13a201a005c6123709ce
  infer_dt :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
53b486f752493b5346a007319f51b2b3
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
9941daa1eb63ee6d632040138430db4b
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main4
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main3
                        GHC.Types.True
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   Main.main2
                   GHC.Types.True
                   ipv2 } }) -}
bf3a391702109635094656dc14118650
  main2 :: GHC.Base.String
  {- Unfolding: (case Main.inferDummy of ww { Simulate.P ww1 ->
                 Simulate.$w$cshow @ Gamble.Flip Gamble.$fShowFlip ww1 }) -}
deda06512e4d6d37a9635d0dc1bfb2e3
  main3 :: GHC.Base.String
  {- Unfolding: (case Main.inferDieNCoins of ww { Simulate.P ww1 ->
                 Simulate.$w$cshow @ Gamble.Roll Gamble.$fShowRoll ww1 }) -}
c2454f8a2a39246db3c0254677c4b10c
  main4 :: GHC.Base.String
  {- Unfolding: (case Main.simpleDieNCoins of ww { Simulate.P ww1 ->
                 case Simulate.$wnormalize
                        @ GHC.Types.Int
                        GHC.Classes.$fEqInt
                        ww1 of ww2 { Unit# ww3 ->
                 Simulate.$w$cshow @ GHC.Types.Int GHC.Show.$fShowInt ww3 } }) -}
61d96313320f49187e5af3716efdb695
  main5 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
be99c8402902eb061a36ea74ab9f1dc5
  simpleDieNCoins :: Simulate.P GHC.Types.Int
  {- Unfolding: (case Simulate.$wuniform
                        @ GHC.Types.Int
                        Main.simpleDieNCoins4 of ww { Unit# ww1 ->
                 case Simulate.$w$c>>=
                        @ GHC.Types.Int
                        @ GHC.Types.Int
                        ww1
                        Main.simpleDieNCoins1 of ww2 { Unit# ww3 ->
                 Simulate.P @ GHC.Types.Int ww3 } }) -}
800c81730c46e95e87405fbe8fb6017c
  simpleDieNCoins1 :: GHC.Types.Int -> Simulate.P GHC.Types.Int
  {- Arity: 1,
     Unfolding: (\ (n :: GHC.Types.Int) ->
                 case Main.$wgo4
                        (GHC.List.replicate
                           @ (Simulate.P Gamble.Flip)
                           n
                           Main.simpleDieNCoins3) of ww { Unit# ww1 ->
                 case Simulate.$w$c>>=
                        @ [Gamble.Flip]
                        @ GHC.Types.Int
                        ww1
                        Main.simpleDieNCoins2 of ww2 { Unit# ww3 ->
                 Simulate.P @ GHC.Types.Int ww3 } }) -}
70602b89902d0a6719b6d7b0fe4e60f1
  simpleDieNCoins2 :: [Gamble.Flip] -> Simulate.P GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [Gamble.Flip]) ->
                 Simulate.P
                   @ GHC.Types.Int
                   (GHC.Types.:
                      @ (GHC.Types.Int, GHC.Real.Rational)
                      (case Main.$wgo3 w 0# of ww { DEFAULT -> GHC.Types.I# ww },
                       Simulate.$fApplicativeP1)
                      (GHC.Types.[] @ (GHC.Types.Int, GHC.Real.Rational)))) -}
ed90bc942eeb52b7f1138b3ecfeba57d
  simpleDieNCoins3 :: Simulate.P Gamble.Flip
  {- Unfolding: (case Simulate.$wuniform
                        @ Gamble.Flip
                        Main.$fEnumerableFlip3 of ww { Unit# ww1 ->
                 Simulate.P @ Gamble.Flip ww1 }) -}
7261e7c5e974ca86f8104255f803f03e
  simpleDieNCoins4 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.eftInt 1# 6#) -}
instance Data.Enumerable.Enumerable [Gamble.Flip]
  = Main.$fEnumerableFlip
instance Data.Enumerable.Enumerable [Gamble.Roll]
  = Main.$fEnumerableRoll
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

